Warning: you are using the standard library and/or the %inline keyword. We
recommend switching on --infer in order to avoid obscure type error messages.
%{

  open MIPSOps
  open LPP
  open Primitive

%}
%start program
%token WRITELN
%token WRITE
%token WHILE
%token VAR
%token SEMICOLON
%token RPAREN
%token READLN
%token RBRACKET
%token PROGRAM
%token PROCEDURE
%token OF
%token NEW
%token LPAREN
%token INTEGER
%token <int32> INTCONST
%token IF
%token <string Location.t> ID
%token FUNCTION
%token END
%token DOT
%token DO
%token COMMA
%token COLONEQ
%token COLON
%token BOOLEAN
%token <bool> BOOLCONST
%token BEGIN
%token ARRAY
%token OR
%token AND
%token NOT
%token NE
%token LT
%token LE
%token GT
%token GE
%token EQ
%token PLUS
%token MINUS
%token TIMES
%token SLASH
%token LBRACKET
%token THEN
%token ELSE
%left OR 
%left AND 
%nonassoc NOT 
%nonassoc NE LT LE GT GE EQ 
%left PLUS MINUS 
%left TIMES SLASH 
%nonassoc unary_minus 
%nonassoc LBRACKET 
%nonassoc THEN 
%nonassoc ELSE 
%type <LPP.program> program
%%

typ:
| _1 = INTEGER
    {    ( TypInt )}
| _1 = BOOLEAN
    {    ( TypBool )}
| _1 = ARRAY _2 = OF t = typ
    {    ( TypArray t )}

expression:
| e = raw_expression
    {    ( Location.make _startpos _endpos e )}
| _1 = LPAREN e = expression _3 = RPAREN
    {    ( e )}

raw_expression:
| i = INTCONST
    {    ( EConst (ConstInt i) )}
| b = BOOLCONST
    {    ( EConst (ConstBool b) )}
| id = ID
    {    ( EGetVar id )}
| _1 = MINUS e = expression %prec unary_minus
    {    ( EUnOp (UOpNeg, e) )}
| e1 = expression _10 = PLUS e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpAdd ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = MINUS e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpSub ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = TIMES e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpMul ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = SLASH e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpDiv ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = LT e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpLt ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = LE e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpLe ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = GT e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpGt ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = GE e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpGe ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = EQ e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpEq ))
in
    ( EBinOp (op, e1, e2) )}
| e1 = expression _10 = NE e2 = expression
    {let op =
  let _1 = _10 in
  (    ( OpNe ))
in
    ( EBinOp (op, e1, e2) )}
| c = callee _2 = LPAREN xs0 = loption_separated_nonempty_list_COMMA_expression__ _4 = RPAREN
    {let actuals =
  let xs = xs0 in
  (    ( xs ))
in
    ( EFunCall (Location.make _startpos_c_ _endpos_c_ c, actuals) )}
| a = expression _2 = LBRACKET i = expression _4 = RBRACKET
    {    ( EArrayGet (a, i) )}
| _1 = NEW _2 = ARRAY _3 = OF t = typ _5 = LBRACKET e = expression _7 = RBRACKET
    {    ( EArrayAlloc (t, e) )}

condition:
| e = expression
    {    ( CExpression e )}
| c = nontrivial_condition
    {    ( c )}

lvalue:
| id = ID
    {    ( fun e -> ISetVar (id, e) )}
| a = expression _2 = LBRACKET i = expression _4 = RBRACKET
    {    ( fun e -> IArraySet (a, i, e) )}

procedure:
| _1 = FUNCTION f = ID _3 = LPAREN formals = separated_bindings _5 = RPAREN _6 = COLON t0 = typ _8 = SEMICOLON locals = variables body = block _11 = SEMICOLON
    {let result =
  let t = t0 in
  (    ( Some t ))
in
    (
      f, {
        formals = formals;
        result = result;
        locals = locals;
        body = body
      }
    )}
| _1 = PROCEDURE f = ID _3 = LPAREN formals = separated_bindings _5 = RPAREN _7 = SEMICOLON locals = variables body = block _10 = SEMICOLON
    {let result =
  (    ( None ))
in
    (
      f, {
        formals = formals;
        result = result;
        locals = locals;
        body = body
      }
    )}

separated_bindings:
| xs0 = loption_separated_nonempty_list_SEMICOLON_binding__
    {let bindings =
  let xs = xs0 in
  (    ( xs ))
in
    ( List.flatten bindings )}

terminated_bindings:
| bindings = nonempty_list_terminated_binding_SEMICOLON__
    {    ( List.flatten bindings )}

variables:
| vars = loption_preceded_VAR_terminated_bindings__
    {    ( vars )}

program:
| _1 = PROGRAM globals = variables defs = list_procedure_ main = block _5 = DOT
    {    ({
       globals = globals;
       defs = defs;
       main = main
    })}

loption_separated_nonempty_list_SEMICOLON_instruction__:
| 
    {    ( [] )}
| x = separated_nonempty_list_SEMICOLON_instruction_
    {    ( x )}

loption_separated_nonempty_list_SEMICOLON_binding__:
| 
    {    ( [] )}
| x = separated_nonempty_list_SEMICOLON_binding_
    {    ( x )}

loption_separated_nonempty_list_COMMA_expression__:
| 
    {    ( [] )}
| x = separated_nonempty_list_COMMA_expression_
    {    ( x )}

loption_preceded_VAR_terminated_bindings__:
| 
    {    ( [] )}
| _10 = VAR x0 = terminated_bindings
    {let x =
  let x = x0 in
  let _1 = _10 in
  (    ( x ))
in
    ( x )}

list_procedure_:
| 
    {    ( [] )}
| x = procedure xs = list_procedure_
    {    ( x :: xs )}

nonempty_list_terminated_binding_SEMICOLON__:
| x0 = binding _20 = SEMICOLON
    {let x =
  let _2 = _20 in
  let x = x0 in
  (    ( x ))
in
    ( [ x ] )}
| x0 = binding _20 = SEMICOLON xs = nonempty_list_terminated_binding_SEMICOLON__
    {let x =
  let _2 = _20 in
  let x = x0 in
  (    ( x ))
in
    ( x :: xs )}

separated_nonempty_list_SEMICOLON_instruction_:
| x = instruction
    {    ( [ x ] )}
| x = instruction _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_instruction_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_binding_:
| x = binding
    {    ( [ x ] )}
| x = binding _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_binding_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_expression_:
| x = expression
    {    ( [ x ] )}
| x = expression _2 = COMMA xs = separated_nonempty_list_COMMA_expression_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_ID_:
| x = ID
    {    ( [ x ] )}
| x = ID _2 = COMMA xs = separated_nonempty_list_COMMA_ID_
    {    ( x :: xs )}

nontrivial_condition:
| _1 = NOT c = condition
    {    ( CNot c )}
| c1 = condition _2 = AND c2 = condition
    {    ( CAnd (c1, c2) )}
| c1 = condition _2 = OR c2 = condition
    {    ( COr (c1, c2) )}
| _1 = LPAREN c = nontrivial_condition _3 = RPAREN
    {    ( c )}

instruction:
| c = callee _2 = LPAREN xs0 = loption_separated_nonempty_list_COMMA_expression__ _4 = RPAREN
    {let actuals =
  let xs = xs0 in
  (    ( xs ))
in
    ( IProcCall (Location.make _startpos_c_ _endpos_c_ c, actuals) )}
| lvalue = lvalue _2 = COLONEQ e = expression
    {    ( (lvalue : LPP.expression -> LPP.instruction) e )}
| _1 = READLN _2 = LPAREN lvalue = lvalue _4 = RPAREN
    {    ( let callee = Location.make _startpos__1_ _endpos__1_ (CPrimitiveFunction Readln) in
      let e = Location.make _startpos _endpos (EFunCall (callee, [])) in
      (lvalue : LPP.expression -> LPP.instruction) e )}
| _1 = IF c = condition _3 = THEN b = instruction_or_block
    {    ( IIf (c, b, ISeq []) )}
| _1 = IF c = condition _3 = THEN b1 = instruction_or_block _5 = ELSE b2 = instruction_or_block
    {    ( IIf (c, b1, b2) )}
| _1 = WHILE c = condition _3 = DO b = instruction_or_block
    {    ( IWhile (c, b) )}

block:
| _1 = BEGIN xs0 = loption_separated_nonempty_list_SEMICOLON_instruction__ _3 = END
    {let is =
  let xs = xs0 in
  (    ( xs ))
in
    ( ISeq is )}

instruction_or_block:
| i = instruction
    {    ( i )}
| b = block
    {    ( b )}

callee:
| _1 = WRITE
    {    ( CPrimitiveFunction Write )}
| _1 = WRITELN
    {    ( CPrimitiveFunction Writeln )}
| id = ID
    {    ( CUserFunction (Location.content id))}

binding:
| ids = separated_nonempty_list_COMMA_ID_ _2 = COLON t = typ
    {    ( List.map (fun id -> (id, t)) ids )}

%%



