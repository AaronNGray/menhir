* Document the recent additions (CHANGES + doc).
  - attributes in .mly files
    rationale / purpose
    syntax of attributes
    placement of attributes
    attributes are incompatible with %inline
    how attributes are propagated during expansion of parameterized definitions
    how %attribute is desugared
  - --cmly command line flag
  - menhirSdk; document the .cmly API...?
  - demo of menhirSdk: generate-printers

* move to gitlab.inria.fr
  see https://help.github.com/articles/splitting-a-subfolder-out-into-a-new-repository/

* clean up this TODO file! and use gitlab issues for known bugs.

* clean up and parallelize the test suite.

* see if ErrorReports could be part of MenhirLib.

* see if --only-preprocess-for-ocamlyacc could be implemented.
  Re-introduce $1 keywords.
  Define $startpos, etc.

* The documentation says not to use _i,
  but --only-preprocess produces it.
  Should we avoid producing it?
  Should we check that it is not used?

* Discussion with Frédéric Bour.
  - Engine: offer richer API
      new stack inspection API, without streams
        stack_next pourrait renvoyer une somme (stack + initial)
        allows comparing stacks
        allows exposing current state even when it is an initial state?
        meta-initial state with transition to the real initial states?
      remonter aussi la fonction element: 'a checkpoint -> int -> element de CompCert
      parameterize the type 'a env again
      ajouter la bijection entre production et int (i2p, p2i)

* Suite des patchs de Frédéric Bour.
    API d'inspection complète.
      Documenter loop_handle_undo, loop_test, acceptable.
      Exposer le nombre d'états (pour la mémoisation).
      Idem pour les productions.
      Fonctions d'affichage pour les types terminal, nonterminal, etc.?
      Fonctions d'isomorphisme entre token et 'a terminal * 'a?

* BUG: the warning "this production is never reduced" is sound but incomplete.
  See never_reduced.mly:
  a: b B | B {}
  b:         {}
  where we get a warning that "b -> " is never reduced, but actually (as a
  result) "a -> b B" is never reduced either. Reword the current warning?
  Document the problem? Develop a new warning based on LRijkstra?
  By the same token, some states could be unreachable, without us knowing.
  What should we do about it?

* Allow splitting a nonterminal symbol (in a file or over multiple files).
  with an explicit keyword? %public?

* standard library: define "%public %inline epsilon: {}", which allows using
  "epsilon" as a marker for an empty right-hand side.

* explain how to simulate inherited attributes in the manual
  (cf. post by David Chemouil on mailing list)

* Look for "artificial dependency" and remove them.
  Make sure every module is explicitly called.

* A %type declaration with parameters is not properly checked;
  it could be useless or even ill-typed.
  Same for %on_error_reduce.

* If the right-hand side of a production provably generates the empty
  language, remove this production. (Must remove it explicitly, otherwise
  we lose the property that errors are detected as early as possible.
  Also, this avoids triggering the detection of epsilon-cycles, which
  assumes that all symbols are inhabited.)
  Currently we warn about nonterminals that generate the empty language.
  Maybe we need a %void annotation when this is intended?
  Document this trick: the empty language can be defined by "void: void"
  and can be used as an actual parameter in parameterized definitions.
  This allows making extensible definitions and instantiating them with
  "no extension".

* --compile-errors could warn about messages wider than 80 columns
                   could also warn statically about out-of-range $i?

* Dans les avantages de Menhir versus ocamlyacc (dans la doc et
  sur la page Web), ajouter le back-end Coq, l'API incrémentale
  et l'API d'inspection, les règles anonymes, la gestion fine des
  erreurs de syntaxe...

* Pénible que l'API d'inspection ne donne pas accès
  à l'état courant lorsque la pile est vide (état initial donc).
  Pourrait-on exposer cet état? Polymorphe? incoming_symbol
  devrait alors produire une option. Et le cas Nil du type
  stream devrait contenir l'état initial...
  attention, car si on lui applique la fonction items, on va
  obtenir un item spécial S' -> S # qui va poser problème.
  Exposer l'état initial avec un type différent lr1initial?

* autoriser %token FOO [@unused]
  équivalent à --unused-token FOO sur la ligne de commande.
  Add an analogous mechanism for nonterminals that are known
  to be unreachable.

* Produce well-chosen (predictable) names for anonymous rules?

* In the standard library, possibly rename "anonymous" and "embedded" and
  document them. The non-inline version allows embedding an action in the
  middle of a rule.

* Add left-recursive lists to the standard library.

* Define [print_checkpoint].
  Define a printer that shows the states in the stack.

* Documenter la différence de philosophie avec Denny & Malloy à propos
  des conflits (cf. email à Laurence Tratt).

* bundle the Coq library with menhir, and add demos/calc-coq
  to show how it is used

* BUG: la directive $type<...> nt donne lieu à un message d'erreur bizarre
  si le non-terminal nt n'existe pas. (Jacques-Henri.)

* On pourrait rendre moins restrictif le critère qui garantit la terminaison
  de l'expansion des non-terminaux paramétrés. Il suffirait de vérifier que
  les paramètres effectifs sont toujours des atomes (symboles terminaux ou
  non-terminaux), non? (Jacques-Henri.)

* Reconnaître les directives # n "foo" dans le fichier .mly et en tenir
  compte dans les locations.

* BUG: message de Valentin Gatien-Baron du 09/01/2010: le bug de --explain
  est-il bien le bug connu? peut-on le corriger? ne suffirait-il pas de
  passer sous silence les conflits qui ont lieu dans une partie inaccessible
  de l'automate?

* Implémenter un test de détection de boucles. Si la grammaire contient une
  boucle, elle est infiniment ambiguë. Pour le test, calculer tous les
  nullables, ajouter une production unité A -> B dès qu'il existe une
  production A -> alpha B beta avec alpha et beta nullables, et regarder
  ensuite s'il existe un cycle de productions unité.

* Permettre une trace avec autre chose que fprintf stderr. Cela permettrait
  au programmeur (par exemple) de décider à runtime s'il veut afficher ou
  non la trace. (En mode --trace.) Et si possible, donner accès depuis
  l'extérieur à la fonction print_token qui est engendrée.

* (petit) BUG: --follow-construction n'affiche pas le contenu des états
  initiaux (r0)

* que fait/que doit faire la combinaison --tokens-only --depend?

* Préserver dirname/ dans les directives #line émises.

* BUG: Boris (1.- bouclage parser sur une entrée erronée 2.- une lecture
  trop loin dans le stream, également liée à error).

* éviter "Warning: 22 conflicts ..." car emacs prend "Warning" pour un
  nom de fichier; d'après Damien, il devrait suffire que la phrase après
  les deux points ne commence pas par un nombre.

* si une variable est inutilisée dans une action sémantique, le
  warning est affiché dans le code produit.

* BUG: solving a shift/reduce conflict in favor of reduction can
  cut a path that was required in order to explain another conflict.
  (see e.g. belloeil.mly) (et le reduced_parser.mly d'Adrien Guatto)
  (also check the parser.mly sent by Andrej Bauer on 2016/01/21)
  Or just give up on explaining the conflict in this case.
  Take priorities into account *during* the construction of the
  automaton? Is it feasible? Compatible with Pager?

* BUG: cutdown.mly

* le fichier .conflicts devrait etre supprime par --explain s'il
  n'y a aucun conflit

* dans le dump de l'automate, rajouter les transitions qui ont
  ete supprimees par resolution de conflits. Afficher aussi les
  réductions par défaut?
