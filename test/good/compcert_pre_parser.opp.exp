%{
  open Pre_parser_aux

  let set_id_type (_,r,_) t =
    r := t

  let declare_varname (i,_,_) =
    !declare_varname i

  let declare_typename (i,_,_) =
    !declare_typename i

  let syntax_error pos =
    Cerrors.fatal_error "%s:%d: syntax error"
        pos.Lexing.pos_fname pos.Lexing.pos_lnum

  let unclosed opening closing pos1 pos2 =
    Cerrors.info "%s:%d: syntax error: expecting '%s'"
        pos2.Lexing.pos_fname pos2.Lexing.pos_lnum closing;
    Cerrors.fatal_error "%s:%d: this is the location of the unclosed '%s'"
        pos1.Lexing.pos_fname pos1.Lexing.pos_lnum opening

%}
%start translation_unit_file
%token <Cabs.cabsloc> ADD_ASSIGN
%token <Cabs.cabsloc> ALIGNAS
%token <Cabs.cabsloc> ALIGNOF
%token <Cabs.cabsloc> AND
%token <Cabs.cabsloc> ANDAND
%token <Cabs.cabsloc> AND_ASSIGN
%token <Cabs.cabsloc> ASM
%token <Cabs.cabsloc> ATTRIBUTE
%token <Cabs.cabsloc> AUTO
%token <Cabs.cabsloc> BANG
%token <Cabs.cabsloc> BAR
%token <Cabs.cabsloc> BARBAR
%token <Cabs.cabsloc> BREAK
%token <Cabs.cabsloc> BUILTIN_VA_ARG
%token <Cabs.cabsloc> CASE
%token <Cabs.cabsloc> CHAR
%token <Cabs.cabsloc> COLON
%token <Cabs.cabsloc> COMMA
%token <Cabs.cabsloc> CONST
%token <Cabs.constant * Cabs.cabsloc> CONSTANT
%token <Cabs.cabsloc> CONTINUE
%token <Cabs.cabsloc> DEC
%token <Cabs.cabsloc> DEFAULT
%token <Cabs.cabsloc> DIV_ASSIGN
%token <Cabs.cabsloc> DO
%token <Cabs.cabsloc> DOT
%token <Cabs.cabsloc> DOUBLE
%token <Cabs.cabsloc> ELLIPSIS
%token <Cabs.cabsloc> ELSE
%token <Cabs.cabsloc> ENUM
%token EOF
%token <Cabs.cabsloc> EQ
%token <Cabs.cabsloc> EQEQ
%token <Cabs.cabsloc> EXTERN
%token <Cabs.cabsloc> FLOAT
%token <Cabs.cabsloc> FOR
%token <Cabs.cabsloc> GEQ
%token <Cabs.cabsloc> GOTO
%token <Cabs.cabsloc> GT
%token <Cabs.cabsloc> HAT
%token <Cabs.cabsloc> IF
%token <Cabs.cabsloc> INC
%token <Cabs.cabsloc> INLINE
%token <Cabs.cabsloc> INT
%token <Cabs.cabsloc> LBRACE
%token <Cabs.cabsloc> LBRACK
%token <Cabs.cabsloc> LEFT
%token <Cabs.cabsloc> LEFT_ASSIGN
%token <Cabs.cabsloc> LEQ
%token <Cabs.cabsloc> LONG
%token <Cabs.cabsloc> LPAREN
%token <Cabs.cabsloc> LT
%token <Cabs.cabsloc> MINUS
%token <Cabs.cabsloc> MOD_ASSIGN
%token <Cabs.cabsloc> MUL_ASSIGN
%token <Cabs.cabsloc> NEQ
%token <Cabs.cabsloc> OR_ASSIGN
%token <Cabs.cabsloc> PACKED
%token <Cabs.cabsloc> PERCENT
%token <Cabs.cabsloc> PLUS
%token <string * Cabs.cabsloc> PRAGMA
%token <Cabs.cabsloc> PTR
%token <Cabs.cabsloc> QUESTION
%token <Cabs.cabsloc> RBRACE
%token <Cabs.cabsloc> RBRACK
%token <Cabs.cabsloc> REGISTER
%token <Cabs.cabsloc> RESTRICT
%token <Cabs.cabsloc> RETURN
%token <Cabs.cabsloc> RIGHT
%token <Cabs.cabsloc> RIGHT_ASSIGN
%token <Cabs.cabsloc> RPAREN
%token <Cabs.cabsloc> SEMICOLON
%token <Cabs.cabsloc> SHORT
%token <Cabs.cabsloc> SIGNED
%token <Cabs.cabsloc> SIZEOF
%token <Cabs.cabsloc> SLASH
%token <Cabs.cabsloc> STAR
%token <Cabs.cabsloc> STATIC
%token <bool * int64 list * Cabs.cabsloc> STRING_LITERAL
%token <Cabs.cabsloc> STRUCT
%token <Cabs.cabsloc> SUB_ASSIGN
%token <Cabs.cabsloc> SWITCH
%token <Cabs.cabsloc> TILDE
%token <Cabs.cabsloc> TYPEDEF
%token <string * Pre_parser_aux.identifier_type ref * Cabs.cabsloc> TYPEDEF_NAME
%token <Cabs.cabsloc> UNDERSCORE_BOOL
%token <Cabs.cabsloc> UNION
%token <Cabs.cabsloc> UNSIGNED
%token <string * Pre_parser_aux.identifier_type ref * Cabs.cabsloc> VAR_NAME
%token <Cabs.cabsloc> VOID
%token <Cabs.cabsloc> VOLATILE
%token <Cabs.cabsloc> WHILE
%token <Cabs.cabsloc> XOR_ASSIGN
%nonassoc TYPEDEF_NAME
%nonassoc highPrec
%type <unit> translation_unit_file
%%

general_identifier:
  i = VAR_NAME
    {    ( i )}
| i = TYPEDEF_NAME
    {    ( i )}

string_literals_list:
  _1 = STRING_LITERAL
    {    ()}
| _1 = string_literals_list _2 = STRING_LITERAL
    {    ()}

push_context:
   %prec highPrec
    {                            ( !push_context () )}

pop_context:
  
    {              ( !pop_context () )}

in_context_compcert_pre_parser_option_block_item_list__:
  _1 = push_context _3 = pop_context
    {let x =
      ( None )
in
                                  ( x )}
| _1 = push_context x0 = block_item_list _3 = pop_context
    {let x =
  let x = x0 in
      ( Some x )
in
                                  ( x )}

in_context_compcert_pre_parser_option_parameter_type_list__:
  _1 = push_context _3 = pop_context
    {let x =
      ( None )
in
                                  ( x )}
| _1 = push_context x0 = parameter_type_list _3 = pop_context
    {let x =
  let x = x0 in
      ( Some x )
in
                                  ( x )}

in_context_declaration_list_:
  _1 = push_context x = declaration_list _3 = pop_context
    {                                  ( x )}

declare_varname_enumerator_:
  i = enumerator
    {         ( declare_varname i; i )}

declare_varname_fst_declarator__:
  x0 = declarator
    {let i =
  let x = x0 in
      ( fst x )
in
         ( declare_varname i; i )}

declare_typename_fst_declarator__:
  x0 = declarator
    {let i =
  let x = x0 in
      ( fst x )
in
         ( declare_typename i; i )}

primary_expression:
  i = VAR_NAME
    {    ( set_id_type i VarId )}
| _1 = CONSTANT
    {    ()}
| _1 = string_literals_list
    {    ()}
| _1 = LPAREN _2 = expression _3 = RPAREN
    {    ()}
| _1 = LPAREN _2 = expression _3 = error
    {let _endpos = _endpos__3_ in
    ( unclosed "(" ")" _startpos__1_ _endpos )}

postfix_expression:
  _1 = primary_expression
    {    ()}
| _1 = postfix_expression _2 = LBRACK _3 = expression _4 = RBRACK
    {    ()}
| _1 = postfix_expression _2 = LPAREN _4 = RPAREN
    {let _3 =
      ( None )
in
    ()}
| _1 = postfix_expression _2 = LPAREN x0 = argument_expression_list _4 = RPAREN
    {let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = postfix_expression _2 = LPAREN _4 = error
    {let _3 =
      ( None )
in
let _endpos = _endpos__4_ in
    ( unclosed "(" ")" _startpos__2_ _endpos )}
| _1 = postfix_expression _2 = LPAREN x0 = argument_expression_list _4 = error
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _endpos = _endpos__4_ in
    ( unclosed "(" ")" _startpos__2_ _endpos )}
| _1 = BUILTIN_VA_ARG _2 = LPAREN _3 = assignment_expression _4 = COMMA _5 = type_name _6 = RPAREN
    {    ()}
| _1 = BUILTIN_VA_ARG _2 = LPAREN _3 = assignment_expression _4 = COMMA _5 = type_name _6 = error
    {let _endpos = _endpos__6_ in
    ( unclosed "(" ")" _startpos__2_ _endpos )}
| _1 = postfix_expression _2 = DOT i = general_identifier
    {    ( set_id_type i OtherId )}
| _1 = postfix_expression _2 = PTR i = general_identifier
    {    ( set_id_type i OtherId )}
| _1 = postfix_expression _2 = INC
    {    ()}
| _1 = postfix_expression _2 = DEC
    {    ()}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = LBRACE _5 = initializer_list _7 = RBRACE
    {let _6 =
      ( None )
in
    ()}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = LBRACE _5 = initializer_list x0 = COMMA _7 = RBRACE
    {let _6 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = LPAREN _2 = type_name _3 = error
    {let _endpos = _endpos__3_ in
    ( unclosed "(" ")" _startpos__1_ _endpos )}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = LBRACE _5 = initializer_list _7 = error
    {let _6 =
      ( None )
in
let _endpos = _endpos__7_ in
    ( unclosed "{" "}" _startpos__4_ _endpos )}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = LBRACE _5 = initializer_list x0 = COMMA _7 = error
    {let _6 =
  let x = x0 in
      ( Some x )
in
let _endpos = _endpos__7_ in
    ( unclosed "{" "}" _startpos__4_ _endpos )}

argument_expression_list:
  _1 = assignment_expression
    {    ()}
| _1 = argument_expression_list _2 = COMMA _3 = assignment_expression
    {    ()}

unary_expression:
  _1 = postfix_expression
    {    ()}
| _1 = INC _2 = unary_expression
    {    ()}
| _1 = DEC _2 = unary_expression
    {    ()}
| _1 = unary_operator _2 = cast_expression
    {    ()}
| _1 = SIZEOF _2 = unary_expression
    {    ()}
| _1 = SIZEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {    ()}
| _1 = ALIGNOF _2 = unary_expression
    {    ()}
| _1 = ALIGNOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {    ()}

unary_operator:
  _1 = AND
    {    ()}
| _1 = STAR
    {    ()}
| _1 = PLUS
    {    ()}
| _1 = MINUS
    {    ()}
| _1 = TILDE
    {    ()}
| _1 = BANG
    {    ()}

cast_expression:
  _1 = unary_expression
    {    ()}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = cast_expression
    {    ()}

multiplicative_expression:
  _1 = cast_expression
    {    ()}
| _1 = multiplicative_expression _2 = STAR _3 = cast_expression
    {    ()}
| _1 = multiplicative_expression _2 = SLASH _3 = cast_expression
    {    ()}
| _1 = multiplicative_expression _2 = PERCENT _3 = cast_expression
    {    ()}

additive_expression:
  _1 = multiplicative_expression
    {    ()}
| _1 = additive_expression _2 = PLUS _3 = multiplicative_expression
    {    ()}
| _1 = additive_expression _2 = MINUS _3 = multiplicative_expression
    {    ()}

shift_expression:
  _1 = additive_expression
    {    ()}
| _1 = shift_expression _2 = LEFT _3 = additive_expression
    {    ()}
| _1 = shift_expression _2 = RIGHT _3 = additive_expression
    {    ()}

relational_expression:
  _1 = shift_expression
    {    ()}
| _1 = relational_expression _2 = LT _3 = shift_expression
    {    ()}
| _1 = relational_expression _2 = GT _3 = shift_expression
    {    ()}
| _1 = relational_expression _2 = LEQ _3 = shift_expression
    {    ()}
| _1 = relational_expression _2 = GEQ _3 = shift_expression
    {    ()}

equality_expression:
  _1 = relational_expression
    {    ()}
| _1 = equality_expression _2 = EQEQ _3 = relational_expression
    {    ()}
| _1 = equality_expression _2 = NEQ _3 = relational_expression
    {    ()}

and_expression:
  _1 = equality_expression
    {    ()}
| _1 = and_expression _2 = AND _3 = equality_expression
    {    ()}

exclusive_or_expression:
  _1 = and_expression
    {    ()}
| _1 = exclusive_or_expression _2 = HAT _3 = and_expression
    {    ()}

inclusive_or_expression:
  _1 = exclusive_or_expression
    {    ()}
| _1 = inclusive_or_expression _2 = BAR _3 = exclusive_or_expression
    {    ()}

logical_and_expression:
  _1 = inclusive_or_expression
    {    ()}
| _1 = logical_and_expression _2 = ANDAND _3 = inclusive_or_expression
    {    ()}

logical_or_expression:
  _1 = logical_and_expression
    {    ()}
| _1 = logical_or_expression _2 = BARBAR _3 = logical_and_expression
    {    ()}

conditional_expression:
  _1 = logical_or_expression
    {    ()}
| _1 = logical_or_expression _2 = QUESTION _3 = expression _4 = COLON _5 = conditional_expression
    {    ()}

assignment_expression:
  _1 = conditional_expression
    {    ()}
| _1 = unary_expression _2 = assignment_operator _3 = assignment_expression
    {    ()}

assignment_operator:
  _1 = EQ
    {    ()}
| _1 = MUL_ASSIGN
    {    ()}
| _1 = DIV_ASSIGN
    {    ()}
| _1 = MOD_ASSIGN
    {    ()}
| _1 = ADD_ASSIGN
    {    ()}
| _1 = SUB_ASSIGN
    {    ()}
| _1 = LEFT_ASSIGN
    {    ()}
| _1 = RIGHT_ASSIGN
    {    ()}
| _1 = AND_ASSIGN
    {    ()}
| _1 = XOR_ASSIGN
    {    ()}
| _1 = OR_ASSIGN
    {    ()}

expression:
  _1 = assignment_expression
    {    ()}
| _1 = expression _2 = COMMA _3 = assignment_expression
    {    ()}

constant_expression:
  _1 = conditional_expression
    {    ()}

declaration:
  _1 = declaration_specifiers _3 = SEMICOLON
    {let _2 =
      ( None )
in
    ()}
| _1 = declaration_specifiers x0 = init_declarator_list _3 = SEMICOLON
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = declaration_specifiers_typedef _3 = SEMICOLON
    {let _2 =
      ( None )
in
    ()}
| _1 = declaration_specifiers_typedef x0 = typedef_declarator_list _3 = SEMICOLON
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

declaration_specifiers_no_type:
  _1 = storage_class_specifier_no_typedef
    {let _2 =
      ( None )
in
    ()}
| _1 = storage_class_specifier_no_typedef x0 = declaration_specifiers_no_type
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = type_qualifier
    {let _2 =
      ( None )
in
    ()}
| _1 = type_qualifier x0 = declaration_specifiers_no_type
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = function_specifier
    {let _2 =
      ( None )
in
    ()}
| _1 = function_specifier x0 = declaration_specifiers_no_type
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

declaration_specifiers_no_typedef_name:
  _1 = storage_class_specifier_no_typedef
    {let _2 =
      ( None )
in
    ()}
| _1 = storage_class_specifier_no_typedef x0 = declaration_specifiers_no_typedef_name
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = type_qualifier
    {let _2 =
      ( None )
in
    ()}
| _1 = type_qualifier x0 = declaration_specifiers_no_typedef_name
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = function_specifier
    {let _2 =
      ( None )
in
    ()}
| _1 = function_specifier x0 = declaration_specifiers_no_typedef_name
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = type_specifier_no_typedef_name
    {let _2 =
      ( None )
in
    ()}
| _1 = type_specifier_no_typedef_name x0 = declaration_specifiers_no_typedef_name
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

declaration_specifiers:
  i = TYPEDEF_NAME
    {let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| i = TYPEDEF_NAME x0 = declaration_specifiers_no_type
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type i = TYPEDEF_NAME
    {let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type i = TYPEDEF_NAME x1 = declaration_specifiers_no_type
    {let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| _2 = type_specifier_no_typedef_name
    {let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = type_specifier_no_typedef_name x0 = declaration_specifiers_no_typedef_name
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = type_specifier_no_typedef_name
    {let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = type_specifier_no_typedef_name x1 = declaration_specifiers_no_typedef_name
    {let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

declaration_specifiers_typedef:
  _2 = TYPEDEF i = TYPEDEF_NAME
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| _2 = TYPEDEF i = TYPEDEF_NAME x0 = declaration_specifiers_no_type
    {let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| _2 = TYPEDEF x0 = declaration_specifiers_no_type i = TYPEDEF_NAME
    {let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| _2 = TYPEDEF x0 = declaration_specifiers_no_type i = TYPEDEF_NAME x1 = declaration_specifiers_no_type
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF i = TYPEDEF_NAME
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF i = TYPEDEF_NAME x1 = declaration_specifiers_no_type
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF x1 = declaration_specifiers_no_type i = TYPEDEF_NAME
    {let _5 =
      ( None )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF x1 = declaration_specifiers_no_type i = TYPEDEF_NAME x2 = declaration_specifiers_no_type
    {let _5 =
  let x = x2 in
      ( Some x )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| i = TYPEDEF_NAME _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| i = TYPEDEF_NAME _4 = TYPEDEF x0 = declaration_specifiers_no_type
    {let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| i = TYPEDEF_NAME x0 = declaration_specifiers_no_type _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| i = TYPEDEF_NAME x0 = declaration_specifiers_no_type _4 = TYPEDEF x1 = declaration_specifiers_no_type
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type i = TYPEDEF_NAME _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type i = TYPEDEF_NAME _4 = TYPEDEF x1 = declaration_specifiers_no_type
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type i = TYPEDEF_NAME x1 = declaration_specifiers_no_type _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = declaration_specifiers_no_type i = TYPEDEF_NAME x1 = declaration_specifiers_no_type _4 = TYPEDEF x2 = declaration_specifiers_no_type
    {let _5 =
  let x = x2 in
      ( Some x )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| _2 = TYPEDEF _4 = type_specifier_no_typedef_name
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = TYPEDEF _4 = type_specifier_no_typedef_name x0 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = TYPEDEF x0 = declaration_specifiers_no_type _4 = type_specifier_no_typedef_name
    {let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| _2 = TYPEDEF x0 = declaration_specifiers_no_type _4 = type_specifier_no_typedef_name x1 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF _4 = type_specifier_no_typedef_name
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF _4 = type_specifier_no_typedef_name x1 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF x1 = declaration_specifiers_no_type _4 = type_specifier_no_typedef_name
    {let _5 =
      ( None )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = TYPEDEF x1 = declaration_specifiers_no_type _4 = type_specifier_no_typedef_name x2 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x2 in
      ( Some x )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| _2 = type_specifier_no_typedef_name _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = type_specifier_no_typedef_name _4 = TYPEDEF x0 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = type_specifier_no_typedef_name x0 = declaration_specifiers_no_typedef_name _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| _2 = type_specifier_no_typedef_name x0 = declaration_specifiers_no_typedef_name _4 = TYPEDEF x1 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = type_specifier_no_typedef_name _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = type_specifier_no_typedef_name _4 = TYPEDEF x1 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = type_specifier_no_typedef_name x1 = declaration_specifiers_no_typedef_name _4 = TYPEDEF
    {let _5 =
      ( None )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = declaration_specifiers_no_type _2 = type_specifier_no_typedef_name x1 = declaration_specifiers_no_typedef_name _4 = TYPEDEF x2 = declaration_specifiers_no_typedef_name
    {let _5 =
  let x = x2 in
      ( Some x )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

init_declarator_list:
  _1 = init_declarator
    {    ()}
| _1 = init_declarator_list _2 = COMMA _3 = init_declarator
    {    ()}

init_declarator:
  _1 = declare_varname_fst_declarator__
    {    ( )}
| _1 = declare_varname_fst_declarator__ _2 = EQ _3 = c_initializer
    {    ( )}

typedef_declarator_list:
  _1 = typedef_declarator
    {    ()}
| _1 = typedef_declarator_list _2 = COMMA _3 = typedef_declarator
    {    ()}

typedef_declarator:
  _1 = declare_typename_fst_declarator__
    {    ( )}

storage_class_specifier_no_typedef:
  _1 = EXTERN
    {    ()}
| _1 = STATIC
    {    ()}
| _1 = AUTO
    {    ()}
| _1 = REGISTER
    {    ()}

type_specifier_no_typedef_name:
  _1 = VOID
    {    ()}
| _1 = CHAR
    {    ()}
| _1 = SHORT
    {    ()}
| _1 = INT
    {    ()}
| _1 = LONG
    {    ()}
| _1 = FLOAT
    {    ()}
| _1 = DOUBLE
    {    ()}
| _1 = SIGNED
    {    ()}
| _1 = UNSIGNED
    {    ()}
| _1 = UNDERSCORE_BOOL
    {    ()}
| _1 = struct_or_union_specifier
    {    ()}
| _1 = enum_specifier
    {    ()}

struct_or_union_specifier:
  _1 = struct_or_union _2 = attribute_specifier_list _3 = LBRACE _4 = struct_declaration_list _5 = RBRACE
    {    ()}
| _1 = struct_or_union _2 = attribute_specifier_list i = general_identifier _4 = LBRACE _5 = struct_declaration_list _6 = RBRACE
    {    ( set_id_type i OtherId )}
| _1 = struct_or_union _2 = attribute_specifier_list i = general_identifier
    {    ( set_id_type i OtherId )}
| _1 = struct_or_union _2 = attribute_specifier_list _3 = LBRACE _4 = struct_declaration_list _5 = error
    {let _endpos = _endpos__5_ in
    ( unclosed "{" "}" _startpos__3_ _endpos )}
| _1 = struct_or_union _2 = attribute_specifier_list _3 = general_identifier _4 = LBRACE _5 = struct_declaration_list _6 = error
    {let _endpos = _endpos__6_ in
    ( unclosed "{" "}" _startpos__4_ _endpos )}

struct_or_union:
  _1 = STRUCT
    {    ()}
| _1 = UNION
    {    ()}

struct_declaration_list:
  
    {    ()}
| _1 = struct_declaration_list _2 = struct_declaration
    {    ()}

struct_declaration:
  _1 = specifier_qualifier_list _3 = SEMICOLON
    {let _2 =
      ( None )
in
    ()}
| _1 = specifier_qualifier_list x0 = struct_declarator_list _3 = SEMICOLON
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

specifier_qualifier_list:
  i = TYPEDEF_NAME
    {let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| i = TYPEDEF_NAME x0 = type_qualifier_list
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ( set_id_type i TypedefId )}
| x0 = type_qualifier_list i = TYPEDEF_NAME
    {let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| x0 = type_qualifier_list i = TYPEDEF_NAME x1 = type_qualifier_list
    {let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i TypedefId )}
| _2 = type_specifier_no_typedef_name
    {let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = type_specifier_no_typedef_name x0 = specifier_qualifier_list_no_typedef_name
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| x0 = type_qualifier_list _2 = type_specifier_no_typedef_name
    {let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = type_qualifier_list _2 = type_specifier_no_typedef_name x1 = specifier_qualifier_list_no_typedef_name
    {let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

specifier_qualifier_list_no_typedef_name:
  _1 = type_specifier_no_typedef_name
    {let _2 =
      ( None )
in
    ()}
| _1 = type_specifier_no_typedef_name x0 = specifier_qualifier_list_no_typedef_name
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = type_qualifier
    {let _2 =
      ( None )
in
    ()}
| _1 = type_qualifier x0 = specifier_qualifier_list_no_typedef_name
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

struct_declarator_list:
  _1 = struct_declarator
    {    ()}
| _1 = struct_declarator_list _2 = COMMA _3 = struct_declarator
    {    ()}

struct_declarator:
  _1 = declarator
    {    ()}
| _2 = COLON _3 = constant_expression
    {let _1 =
      ( None )
in
    ()}
| x0 = declarator _2 = COLON _3 = constant_expression
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

enum_specifier:
  _1 = ENUM _2 = attribute_specifier_list _3 = LBRACE _4 = enumerator_list _6 = RBRACE
    {let _5 =
      ( None )
in
    ()}
| _1 = ENUM _2 = attribute_specifier_list _3 = LBRACE _4 = enumerator_list x0 = COMMA _6 = RBRACE
    {let _5 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = ENUM _2 = attribute_specifier_list i = general_identifier _4 = LBRACE _5 = enumerator_list _7 = RBRACE
    {let _6 =
      ( None )
in
    ( set_id_type i OtherId )}
| _1 = ENUM _2 = attribute_specifier_list i = general_identifier _4 = LBRACE _5 = enumerator_list x0 = COMMA _7 = RBRACE
    {let _6 =
  let x = x0 in
      ( Some x )
in
    ( set_id_type i OtherId )}
| _1 = ENUM _2 = attribute_specifier_list i = general_identifier
    {    ( set_id_type i OtherId )}
| _1 = ENUM _2 = attribute_specifier_list _3 = LBRACE _4 = enumerator_list _6 = error
    {let _5 =
      ( None )
in
let _endpos = _endpos__6_ in
    ( unclosed "{" "}" _startpos__3_ _endpos )}
| _1 = ENUM _2 = attribute_specifier_list _3 = LBRACE _4 = enumerator_list x0 = COMMA _6 = error
    {let _5 =
  let x = x0 in
      ( Some x )
in
let _endpos = _endpos__6_ in
    ( unclosed "{" "}" _startpos__3_ _endpos )}
| _1 = ENUM _2 = attribute_specifier_list _3 = general_identifier _4 = LBRACE _5 = enumerator_list _7 = error
    {let _6 =
      ( None )
in
let _endpos = _endpos__7_ in
    ( unclosed "{" "}" _startpos__4_ _endpos )}
| _1 = ENUM _2 = attribute_specifier_list _3 = general_identifier _4 = LBRACE _5 = enumerator_list x0 = COMMA _7 = error
    {let _6 =
  let x = x0 in
      ( Some x )
in
let _endpos = _endpos__7_ in
    ( unclosed "{" "}" _startpos__4_ _endpos )}

enumerator_list:
  _1 = declare_varname_enumerator_
    {    ()}
| _1 = enumerator_list _2 = COMMA _3 = declare_varname_enumerator_
    {    ()}

enumerator:
  i = enumeration_constant
    {    ( i )}
| i = enumeration_constant _2 = EQ _3 = constant_expression
    {    ( i )}

enumeration_constant:
  i = general_identifier
    {    ( set_id_type i VarId; i )}

type_qualifier:
  _1 = CONST
    {    ()}
| _1 = RESTRICT
    {    ()}
| _1 = VOLATILE
    {    ()}
| _1 = attribute_specifier
    {    ()}

attribute_specifier_list:
  
    {    ()}
| _1 = attribute_specifier_list _2 = attribute_specifier
    {    ()}

attribute_specifier:
  _1 = ATTRIBUTE _2 = LPAREN _3 = LPAREN _4 = gcc_attribute_list _5 = RPAREN _6 = RPAREN
    {    ()}
| _1 = PACKED _2 = LPAREN _3 = argument_expression_list _4 = RPAREN
    {    ()}
| _1 = ALIGNAS _2 = LPAREN _3 = argument_expression_list _4 = RPAREN
    {    ()}
| _1 = ALIGNAS _2 = LPAREN _3 = type_name _4 = RPAREN
    {    ()}

gcc_attribute_list:
  _1 = gcc_attribute
    {    ()}
| _1 = gcc_attribute_list _2 = COMMA _3 = gcc_attribute
    {    ()}

gcc_attribute:
  
    {    ()}
| _1 = gcc_attribute_word
    {    ()}
| _1 = gcc_attribute_word _2 = LPAREN _4 = RPAREN
    {let _3 =
      ( None )
in
    ()}
| _1 = gcc_attribute_word _2 = LPAREN x0 = argument_expression_list _4 = RPAREN
    {let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = gcc_attribute_word _2 = LPAREN i = TYPEDEF_NAME _4 = COMMA _5 = argument_expression_list _6 = RPAREN
    {    ( set_id_type i VarId )}

gcc_attribute_word:
  i = general_identifier
    {    ( set_id_type i OtherId )}
| _1 = CONST
    {    ()}
| _1 = PACKED
    {    ()}

function_specifier:
  _1 = INLINE
    {    ()}

declarator:
  x = direct_declarator _3 = attribute_specifier_list
    {let _1 =
      ( None )
in
    ( x )}
| x0 = pointer x = direct_declarator _3 = attribute_specifier_list
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ( x )}

direct_declarator:
  i = general_identifier
    {    ( set_id_type i VarId; (i, None) )}
| _1 = LPAREN x = declarator _3 = RPAREN
    {    ( x )}
| x = direct_declarator _2 = LBRACK _5 = RBRACK
    {let _4 =
      ( None )
in
let _3 =
      ( None )
in
    ( x )}
| x = direct_declarator _2 = LBRACK x0 = assignment_expression _5 = RBRACK
    {let _4 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
    ( x )}
| x = direct_declarator _2 = LBRACK x0 = type_qualifier_list _5 = RBRACK
    {let _4 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ( x )}
| x = direct_declarator _2 = LBRACK x0 = type_qualifier_list x1 = assignment_expression _5 = RBRACK
    {let _4 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ( x )}
| x = direct_declarator _2 = LPAREN l = in_context_compcert_pre_parser_option_parameter_type_list__ _4 = RPAREN
    {    ( match snd x with
      | None -> (fst x, Some (match l with None -> [] | Some l -> l))
      | Some _ -> x )}

pointer:
  _1 = STAR
    {let _2 =
      ( None )
in
    ()}
| _1 = STAR x0 = type_qualifier_list
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = STAR _3 = pointer
    {let _2 =
      ( None )
in
    ()}
| _1 = STAR x0 = type_qualifier_list _3 = pointer
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

type_qualifier_list:
  _2 = type_qualifier
    {let _1 =
      ( None )
in
    ()}
| x0 = type_qualifier_list _2 = type_qualifier
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

parameter_type_list:
  l = parameter_list
    {    ( l )}
| l = parameter_list _2 = COMMA _3 = ELLIPSIS
    {    ( l )}

parameter_list:
  i = parameter_declaration
    {    ( [i] )}
| l = parameter_list _2 = COMMA i = parameter_declaration
    {    ( i::l )}

parameter_declaration:
  _1 = declaration_specifiers id = declare_varname_fst_declarator__
    {    ( Some id )}
| _1 = declaration_specifiers
    {let _2 =
      ( None )
in
    ( None )}
| _1 = declaration_specifiers x0 = abstract_declarator
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ( None )}

type_name:
  _1 = specifier_qualifier_list
    {let _2 =
      ( None )
in
    ()}
| _1 = specifier_qualifier_list x0 = abstract_declarator
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

abstract_declarator:
  _1 = pointer
    {    ()}
| _2 = direct_abstract_declarator
    {let _1 =
      ( None )
in
    ()}
| x0 = pointer _2 = direct_abstract_declarator
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

direct_abstract_declarator:
  _1 = LPAREN _2 = abstract_declarator _3 = RPAREN
    {    ()}
| _2 = LBRACK _5 = RBRACK
    {let _4 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = LBRACK x0 = assignment_expression _5 = RBRACK
    {let _4 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
      ( None )
in
    ()}
| _2 = LBRACK x0 = type_qualifier_list _5 = RBRACK
    {let _4 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| _2 = LBRACK x0 = type_qualifier_list x1 = assignment_expression _5 = RBRACK
    {let _4 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
let _1 =
      ( None )
in
    ()}
| x0 = direct_abstract_declarator _2 = LBRACK _5 = RBRACK
    {let _4 =
      ( None )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = direct_abstract_declarator _2 = LBRACK x1 = assignment_expression _5 = RBRACK
    {let _4 =
  let x = x1 in
      ( Some x )
in
let _3 =
      ( None )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = direct_abstract_declarator _2 = LBRACK x1 = type_qualifier_list _5 = RBRACK
    {let _4 =
      ( None )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| x0 = direct_abstract_declarator _2 = LBRACK x1 = type_qualifier_list x2 = assignment_expression _5 = RBRACK
    {let _4 =
  let x = x2 in
      ( Some x )
in
let _3 =
  let x = x1 in
      ( Some x )
in
let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| _2 = LPAREN _3 = in_context_compcert_pre_parser_option_parameter_type_list__ _4 = RPAREN
    {let _1 =
      ( None )
in
    ()}
| x0 = direct_abstract_declarator _2 = LPAREN _3 = in_context_compcert_pre_parser_option_parameter_type_list__ _4 = RPAREN
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

c_initializer:
  _1 = assignment_expression
    {    ()}
| _1 = LBRACE _2 = initializer_list _4 = RBRACE
    {let _3 =
      ( None )
in
    ()}
| _1 = LBRACE _2 = initializer_list x0 = COMMA _4 = RBRACE
    {let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = LBRACE _2 = initializer_list _4 = error
    {let _3 =
      ( None )
in
let _endpos = _endpos__4_ in
    ( unclosed "{" "}" _startpos__1_ _endpos )}
| _1 = LBRACE _2 = initializer_list x0 = COMMA _4 = error
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _endpos = _endpos__4_ in
    ( unclosed "{" "}" _startpos__1_ _endpos )}

initializer_list:
  _2 = c_initializer
    {let _1 =
      ( None )
in
    ()}
| x0 = designation _2 = c_initializer
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = initializer_list _2 = COMMA _4 = c_initializer
    {let _3 =
      ( None )
in
    ()}
| _1 = initializer_list _2 = COMMA x0 = designation _4 = c_initializer
    {let _3 =
  let x = x0 in
      ( Some x )
in
    ()}

designation:
  _1 = designator_list _2 = EQ
    {    ()}

designator_list:
  _2 = designator
    {let _1 =
      ( None )
in
    ()}
| x0 = designator_list _2 = designator
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

designator:
  _1 = LBRACK _2 = constant_expression _3 = RBRACK
    {    ()}
| _1 = DOT i = general_identifier
    {    ( set_id_type i OtherId )}

statement_finish:
  _1 = labeled_statement_statement_finish_
    {    ()}
| _1 = compound_statement
    {    ()}
| _1 = expression_statement
    {    ()}
| _1 = selection_statement_finish
    {    ()}
| _1 = iteration_statement_statement_finish_
    {    ()}
| _1 = jump_statement
    {    ()}
| _1 = asm_statement
    {    ()}

statement_intern:
  _1 = labeled_statement_statement_intern_
    {    ()}
| _1 = compound_statement
    {    ()}
| _1 = expression_statement
    {    ()}
| _1 = selection_statement_intern
    {    ()}
| _1 = iteration_statement_statement_intern_
    {    ()}
| _1 = jump_statement
    {    ()}
| _1 = asm_statement
    {    ()}

labeled_statement_statement_finish_:
  i = general_identifier _2 = COLON _3 = statement_finish
    {    ( set_id_type i OtherId )}
| _1 = CASE _2 = constant_expression _3 = COLON _4 = statement_finish
    {    ()}
| _1 = DEFAULT _2 = COLON _3 = statement_finish
    {    ()}

labeled_statement_statement_intern_:
  i = general_identifier _2 = COLON _3 = statement_intern
    {    ( set_id_type i OtherId )}
| _1 = CASE _2 = constant_expression _3 = COLON _4 = statement_intern
    {    ()}
| _1 = DEFAULT _2 = COLON _3 = statement_intern
    {    ()}

compound_statement:
  _1 = LBRACE _2 = in_context_compcert_pre_parser_option_block_item_list__ _3 = RBRACE
    {    ()}
| _1 = LBRACE _2 = in_context_compcert_pre_parser_option_block_item_list__ _3 = error
    {let _endpos = _endpos__3_ in
    ( unclosed "{" "}" _startpos__1_ _endpos )}

block_item_list:
  _2 = block_item
    {let _1 =
      ( None )
in
    ()}
| x0 = block_item_list _2 = block_item
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

block_item:
  _1 = declaration
    {    ()}
| _1 = statement_finish
    {    ()}
| _1 = PRAGMA
    {    ()}

expression_statement:
  _2 = SEMICOLON
    {let _1 =
      ( None )
in
    ()}
| x0 = expression _2 = SEMICOLON
    {let _1 =
  let x = x0 in
      ( Some x )
in
    ()}

selection_statement_finish:
  _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_finish
    {    ()}
| _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_intern _6 = ELSE _7 = statement_finish
    {    ()}
| _1 = SWITCH _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_finish
    {    ()}

selection_statement_intern:
  _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_intern _6 = ELSE _7 = statement_intern
    {    ()}
| _1 = SWITCH _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_intern
    {    ()}

iteration_statement_statement_finish_:
  _1 = WHILE _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_finish
    {    ()}
| _1 = DO _2 = statement_finish _3 = WHILE _4 = LPAREN _5 = expression _6 = RPAREN _7 = SEMICOLON
    {    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _6 = SEMICOLON _8 = RPAREN _9 = statement_finish
    {let _7 =
      ( None )
in
let _5 =
      ( None )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _6 = SEMICOLON x0 = expression _8 = RPAREN _9 = statement_finish
    {let _7 =
  let x = x0 in
      ( Some x )
in
let _5 =
      ( None )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON x0 = expression _6 = SEMICOLON _8 = RPAREN _9 = statement_finish
    {let _7 =
      ( None )
in
let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON x0 = expression _6 = SEMICOLON x1 = expression _8 = RPAREN _9 = statement_finish
    {let _7 =
  let x = x1 in
      ( Some x )
in
let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON _6 = SEMICOLON _8 = RPAREN _9 = statement_finish
    {let _7 =
      ( None )
in
let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON _6 = SEMICOLON x1 = expression _8 = RPAREN _9 = statement_finish
    {let _7 =
  let x = x1 in
      ( Some x )
in
let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON x1 = expression _6 = SEMICOLON _8 = RPAREN _9 = statement_finish
    {let _7 =
      ( None )
in
let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON x1 = expression _6 = SEMICOLON x2 = expression _8 = RPAREN _9 = statement_finish
    {let _7 =
  let x = x2 in
      ( Some x )
in
let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration _6 = SEMICOLON _8 = RPAREN _9 = statement_finish _10 = pop_context
    {let _7 =
      ( None )
in
let _5 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration _6 = SEMICOLON x0 = expression _8 = RPAREN _9 = statement_finish _10 = pop_context
    {let _7 =
  let x = x0 in
      ( Some x )
in
let _5 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration x0 = expression _6 = SEMICOLON _8 = RPAREN _9 = statement_finish _10 = pop_context
    {let _7 =
      ( None )
in
let _5 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration x0 = expression _6 = SEMICOLON x1 = expression _8 = RPAREN _9 = statement_finish _10 = pop_context
    {let _7 =
  let x = x1 in
      ( Some x )
in
let _5 =
  let x = x0 in
      ( Some x )
in
    ()}

iteration_statement_statement_intern_:
  _1 = WHILE _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_intern
    {    ()}
| _1 = DO _2 = statement_finish _3 = WHILE _4 = LPAREN _5 = expression _6 = RPAREN _7 = SEMICOLON
    {    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _6 = SEMICOLON _8 = RPAREN _9 = statement_intern
    {let _7 =
      ( None )
in
let _5 =
      ( None )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _6 = SEMICOLON x0 = expression _8 = RPAREN _9 = statement_intern
    {let _7 =
  let x = x0 in
      ( Some x )
in
let _5 =
      ( None )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON x0 = expression _6 = SEMICOLON _8 = RPAREN _9 = statement_intern
    {let _7 =
      ( None )
in
let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON x0 = expression _6 = SEMICOLON x1 = expression _8 = RPAREN _9 = statement_intern
    {let _7 =
  let x = x1 in
      ( Some x )
in
let _5 =
  let x = x0 in
      ( Some x )
in
let _3 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON _6 = SEMICOLON _8 = RPAREN _9 = statement_intern
    {let _7 =
      ( None )
in
let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON _6 = SEMICOLON x1 = expression _8 = RPAREN _9 = statement_intern
    {let _7 =
  let x = x1 in
      ( Some x )
in
let _5 =
      ( None )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON x1 = expression _6 = SEMICOLON _8 = RPAREN _9 = statement_intern
    {let _7 =
      ( None )
in
let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN x0 = expression _4 = SEMICOLON x1 = expression _6 = SEMICOLON x2 = expression _8 = RPAREN _9 = statement_intern
    {let _7 =
  let x = x2 in
      ( Some x )
in
let _5 =
  let x = x1 in
      ( Some x )
in
let _3 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration _6 = SEMICOLON _8 = RPAREN _9 = statement_intern _10 = pop_context
    {let _7 =
      ( None )
in
let _5 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration _6 = SEMICOLON x0 = expression _8 = RPAREN _9 = statement_intern _10 = pop_context
    {let _7 =
  let x = x0 in
      ( Some x )
in
let _5 =
      ( None )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration x0 = expression _6 = SEMICOLON _8 = RPAREN _9 = statement_intern _10 = pop_context
    {let _7 =
      ( None )
in
let _5 =
  let x = x0 in
      ( Some x )
in
    ()}
| _1 = FOR _2 = LPAREN _3 = push_context _4 = declaration x0 = expression _6 = SEMICOLON x1 = expression _8 = RPAREN _9 = statement_intern _10 = pop_context
    {let _7 =
  let x = x1 in
      ( Some x )
in
let _5 =
  let x = x0 in
      ( Some x )
in
    ()}

jump_statement:
  _1 = GOTO i = general_identifier _3 = SEMICOLON
    {    ( set_id_type i OtherId )}
| _1 = CONTINUE _2 = SEMICOLON
    {    ()}
| _1 = BREAK _2 = SEMICOLON
    {    ()}
| _1 = RETURN _3 = SEMICOLON
    {let _2 =
      ( None )
in
    ()}
| _1 = RETURN x0 = expression _3 = SEMICOLON
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ()}

asm_statement:
  _1 = ASM _2 = asm_attributes _3 = LPAREN _4 = string_literals_list _5 = asm_arguments _6 = RPAREN _7 = SEMICOLON
    {    ()}

asm_attributes:
  
    {    ()}
| _1 = CONST _2 = asm_attributes
    {    ()}
| _1 = VOLATILE _2 = asm_attributes
    {    ()}

asm_arguments:
  
    {    ()}
| _1 = COLON _2 = asm_operands
    {    ()}
| _1 = COLON _2 = asm_operands _3 = COLON _4 = asm_operands
    {    ()}
| _1 = COLON _2 = asm_operands _3 = COLON _4 = asm_operands _5 = COLON _6 = asm_flags
    {    ()}

asm_operands:
  
    {    ()}
| _1 = asm_operands_ne
    {    ()}

asm_operands_ne:
  _1 = asm_operands_ne _2 = COMMA _3 = asm_operand
    {    ()}
| _1 = asm_operand
    {    ()}

asm_operand:
  _1 = asm_op_name _2 = string_literals_list _3 = LPAREN _4 = expression _5 = RPAREN
    {    ()}

asm_op_name:
  
    {                                        ()}
| _1 = LBRACK i = general_identifier _3 = RBRACK
    {                                        ( set_id_type i OtherId )}

asm_flags:
  _1 = string_literals_list
    {    ()}
| _1 = string_literals_list _2 = COMMA _3 = asm_flags
    {    ()}

translation_unit_file:
  _1 = translation_unit _2 = EOF
    {    ()}
| _1 = EOF
    {    ()}
| _1 = error
    {let _endpos = _endpos__1_ in
    ( syntax_error _endpos )}

translation_unit:
  _1 = external_declaration
    {    ()}
| _1 = translation_unit _2 = external_declaration
    {    ()}
| _1 = translation_unit _2 = SEMICOLON
    {    ()}
| _1 = SEMICOLON
    {    ()}

external_declaration:
  _1 = function_definition
    {    ()}
| _1 = declaration
    {    ()}
| _1 = PRAGMA
    {    ()}

function_definition_begin:
  _1 = declaration_specifiers x = direct_declarator
    {let _2 =
      ( None )
in
    ( match x with
      | (_, None) -> (raise _eRR)
      | (i, Some l) ->
	declare_varname i;
	!push_context ();
	List.iter (fun x ->
	  match x with
	    | None -> ()
	    | Some i -> declare_varname i
	  ) l
    )}
| _1 = declaration_specifiers x0 = pointer x = direct_declarator
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ( match x with
      | (_, None) -> (raise _eRR)
      | (i, Some l) ->
	declare_varname i;
	!push_context ();
	List.iter (fun x ->
	  match x with
	    | None -> ()
	    | Some i -> declare_varname i
	  ) l
    )}
| _1 = declaration_specifiers x = direct_declarator _4 = LPAREN params = identifier_list _6 = RPAREN _7 = in_context_declaration_list_
    {let _2 =
      ( None )
in
    ( match x with
      | (_, Some _) -> (raise _eRR)
      | (i, None) ->
	declare_varname i;
	!push_context ();
	List.iter declare_varname params
    )}
| _1 = declaration_specifiers x0 = pointer x = direct_declarator _4 = LPAREN params = identifier_list _6 = RPAREN _7 = in_context_declaration_list_
    {let _2 =
  let x = x0 in
      ( Some x )
in
    ( match x with
      | (_, Some _) -> (raise _eRR)
      | (i, None) ->
	declare_varname i;
	!push_context ();
	List.iter declare_varname params
    )}

identifier_list:
  id = VAR_NAME
    {    ( [id] )}
| idl = identifier_list _2 = COMMA id = VAR_NAME
    {    ( id :: idl )}

declaration_list:
  
    {    ( )}
| _1 = declaration_list _2 = declaration
    {    ( )}

function_definition:
  _1 = function_definition_begin _2 = LBRACE _4 = pop_context _5 = RBRACE
    {let _3 =
      ( None )
in
    ( )}
| _1 = function_definition_begin _2 = LBRACE x0 = block_item_list _4 = pop_context _5 = RBRACE
    {let _3 =
  let x = x0 in
      ( Some x )
in
    ( )}
| _1 = function_definition_begin _2 = LBRACE _4 = pop_context _5 = error
    {let _3 =
      ( None )
in
let _endpos = _endpos__5_ in
    ( unclosed "{" "}" _startpos__2_ _endpos )}
| _1 = function_definition_begin _2 = LBRACE x0 = block_item_list _4 = pop_context _5 = error
    {let _3 =
  let x = x0 in
      ( Some x )
in
let _endpos = _endpos__5_ in
    ( unclosed "{" "}" _startpos__2_ _endpos )}

%%



Note: the nonterminal symbol option (from compcert_pre_parser.mly) is renamed compcert_pre_parser_option.
