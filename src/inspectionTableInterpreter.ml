module Make (T : InspectionTableFormat.TABLES) = struct

  (* This auxiliary function decodes a packed linearized array, as created by
     [TableBackend.linearize_and_marshal1]. Here, we read a row all at once. *)

  let read_packed_linearized ((data, entry) : PackedIntArray.t * PackedIntArray.t) (i : int) : int list =
    LinearizedArray.read_row_via
      (PackedIntArray.get data)
      (PackedIntArray.get entry)
      i

  (* The function [incoming_symbol] is generated by the table back-end.
     We just expose it. *)

  let incoming_symbol =
    T.incoming_symbol

  (* The function [lhs] reads the table [lhs] and uses [T.nonterminal]
     to decode the symbol. *)

  let lhs prod =
    T.nonterminal (PackedIntArray.get T.lhs prod)

  (* The function [rhs] reads the table [rhs] and uses [decode_symbol]
     to decode the symbol. The encoding was done by [encode_symbol] in
     the table back-end. *)

  let decode_symbol symbol =
    let kind = symbol land 1 in
    (if kind = 0 then T.terminal else T.nonterminal) (symbol lsr 1)

  let rhs prod =
    List.map decode_symbol (read_packed_linearized T.rhs prod)

  (* The function [items] maps the LR(1) state [s] to its LR(0) core,
     then uses [core] as an index into the table [lr0_items]. The
     items are then decoded by the function [export] below, which is
     essentially a copy of [Item.export]. *)

  let export t =
    (t lsr 7, t mod 128)

  let items s =
    (* Map [s] to its LR(0) core. *)
    let core = PackedIntArray.get T.lr0_core s in
    (* Now use [core] to look up the [lr0_items] table. *)
    List.map export (read_packed_linearized T.lr0_items core)

end
